// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Curry = require("bs-platform/lib/js/curry.js");
var Belt_Id = require("bs-platform/lib/js/belt_Id.js");
var Belt_Map = require("bs-platform/lib/js/belt_Map.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");

var inputTest = Fs.readFileSync("input/2020/day11test", "utf8").trim().split("\n");

var input = Fs.readFileSync("input/2020/day11", "utf8").trim().split("\n");

var cmp = Caml_obj.caml_compare;

var CoordCmp = Belt_Id.MakeComparable({
      cmp: cmp
    });

function parse(raw) {
  return Belt_Array.reduceWithIndex(raw, Belt_Map.make(CoordCmp), (function (acc, seats, idxY) {
                return Belt_Array.reduceWithIndex(seats.split(""), acc, (function (ac, seat, idxX) {
                              return Belt_Map.set(ac, [
                                          idxX,
                                          idxY
                                        ], seat === "." ? /* Floor */0 : (
                                            seat === "#" ? /* Occupied */1 : /* Empty */2
                                          ));
                            }));
              }));
}

function adjacents(coord) {
  var y = coord[1];
  var x = coord[0];
  return [
          [
            x,
            y - 1 | 0
          ],
          [
            x + 1 | 0,
            y
          ],
          [
            x,
            y + 1 | 0
          ],
          [
            x - 1 | 0,
            y
          ],
          [
            x - 1 | 0,
            y - 1 | 0
          ],
          [
            x + 1 | 0,
            y - 1 | 0
          ],
          [
            x - 1 | 0,
            y + 1 | 0
          ],
          [
            x + 1 | 0,
            y + 1 | 0
          ]
        ];
}

function range(map) {
  return Belt_Map.reduce(map, [
              0,
              0
            ], (function (acc, k, v) {
                return [
                        Caml_primitive.caml_int_max(acc[0], k[0]),
                        Caml_primitive.caml_int_max(acc[1], k[1])
                      ];
              }));
}

function checkCoord(map, coord, status) {
  var match = Belt_Array.reduce(adjacents(coord), [
        0,
        0
      ], (function (acc, adj) {
          var empty = acc[1];
          var occupied = acc[0];
          var state = Belt_Map.get(map, adj);
          if (state === undefined) {
            return acc;
          }
          switch (state) {
            case /* Floor */0 :
                return acc;
            case /* Occupied */1 :
                return [
                        occupied + 1 | 0,
                        empty
                      ];
            case /* Empty */2 :
                return [
                        occupied,
                        empty + 1 | 0
                      ];
            
          }
        }));
  var occ = match[0];
  if (status === /* Empty */2 && occ === 0) {
    return /* Occupied */1;
  } else if (status === /* Occupied */1 && occ >= 4) {
    return /* Empty */2;
  } else {
    return status;
  }
}

function checkCoord2(map, coord, status) {
  if (status === /* Floor */0) {
    return status;
  }
  var y = coord[1];
  var x = coord[0];
  var match = range(map);
  var my = match[1];
  var mx = match[0];
  var seek = function (coords) {
    return Belt_Array.get(Belt_Array.keep(Belt_Array.reduce(coords, [], (function (acc, crd) {
                          var v = Belt_Map.get(map, crd);
                          if (v !== undefined) {
                            return Belt_Array.concat(acc, [v]);
                          } else {
                            return acc;
                          }
                        })), (function (state) {
                      return state !== /* Floor */0;
                    })), 0);
  };
  var up = seek(Belt_Array.map(Belt_Array.reverse(Belt_Array.range(0, y - 1 | 0)), (function (i) {
              return [
                      x,
                      i
                    ];
            })));
  var right = seek(Belt_Array.map(Belt_Array.range(x + 1 | 0, mx), (function (i) {
              return [
                      i,
                      y
                    ];
            })));
  var down = seek(Belt_Array.map(Belt_Array.range(y + 1 | 0, my), (function (i) {
              return [
                      x,
                      i
                    ];
            })));
  var left = seek(Belt_Array.map(Belt_Array.reverse(Belt_Array.range(0, x - 1 | 0)), (function (i) {
              return [
                      i,
                      y
                    ];
            })));
  var upleft = seek(Belt_Array.zip(Belt_Array.reverse(Belt_Array.range(0, x - 1 | 0)), Belt_Array.reverse(Belt_Array.range(0, y - 1 | 0))));
  var upright = seek(Belt_Array.zip(Belt_Array.range(x + 1 | 0, mx), Belt_Array.reverse(Belt_Array.range(0, y - 1 | 0))));
  var downleft = seek(Belt_Array.zip(Belt_Array.reverse(Belt_Array.range(0, x - 1 | 0)), Belt_Array.range(y + 1 | 0, my)));
  var downright = seek(Belt_Array.zip(Belt_Array.range(x + 1 | 0, mx), Belt_Array.range(y + 1 | 0, my)));
  var match$1 = Belt_Array.reduce([
        up,
        right,
        down,
        left,
        upleft,
        upright,
        downleft,
        downright
      ], [
        0,
        0
      ], (function (acc, state) {
          var e = acc[1];
          var o = acc[0];
          if (state === undefined) {
            return acc;
          }
          switch (state) {
            case /* Floor */0 :
                return acc;
            case /* Occupied */1 :
                return [
                        o + 1 | 0,
                        e
                      ];
            case /* Empty */2 :
                return [
                        o,
                        e + 1 | 0
                      ];
            
          }
        }));
  var occ = match$1[0];
  if (status === /* Empty */2 && occ === 0) {
    return /* Occupied */1;
  } else if (status === /* Occupied */1 && occ >= 5) {
    return /* Empty */2;
  } else {
    return status;
  }
}

function scanner(f, _map) {
  while(true) {
    var map = _map;
    var match = Belt_Map.reduce(map, [
          Belt_Map.make(CoordCmp),
          0
        ], (function(map){
        return function (acc, k, v) {
          var count = acc[1];
          var result = Curry._3(f, map, k, v);
          var newCount = result !== v ? count + 1 | 0 : count;
          return [
                  Belt_Map.set(acc[0], k, result),
                  newCount
                ];
        }
        }(map)));
    var changes = match[1];
    var newMap = match[0];
    console.log(changes);
    if (changes === 0) {
      return Belt_Map.reduce(newMap, 0, (function (acc, k, v) {
                    if (v !== 1) {
                      return acc;
                    } else {
                      return acc + 1 | 0;
                    }
                  }));
    }
    _map = newMap;
    continue ;
  };
}

console.log(scanner(checkCoord2, parse(input)));

exports.inputTest = inputTest;
exports.input = input;
exports.CoordCmp = CoordCmp;
exports.parse = parse;
exports.adjacents = adjacents;
exports.range = range;
exports.checkCoord = checkCoord;
exports.checkCoord2 = checkCoord2;
exports.scanner = scanner;
/* inputTest Not a pure module */
