// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");

var inputTest = Fs.readFileSync("input/2020/day08test", "utf8").trim().split("\n");

var input = Fs.readFileSync("input/2020/day08", "utf8").trim().split("\n");

function parse(input) {
  return Belt_Array.map(input, (function (i) {
                var splitted = i.split(" ");
                var value = Caml_format.caml_int_of_string(Belt_Array.getExn(splitted, 1));
                return [
                        Belt_Array.getExn(splitted, 0),
                        value
                      ];
              }));
}

function interpret(inst, _cur, _acc, _history) {
  while(true) {
    var history = _history;
    var acc = _acc;
    var cur = _cur;
    if (Belt_Array.some(history, (function(cur){
          return function (h) {
            return h === cur;
          }
          }(cur)))) {
      return {
              TAG: /* Error */1,
              _0: acc
            };
    }
    if (cur === (inst.length - 1 | 0)) {
      var match = Belt_Array.getExn(inst, cur);
      switch (match[0]) {
        case "acc" :
            return {
                    TAG: /* Ok */0,
                    _0: acc + match[1] | 0
                  };
        case "jmp" :
        case "nop" :
            return {
                    TAG: /* Ok */0,
                    _0: acc
                  };
        default:
          return {
                  TAG: /* Ok */0,
                  _0: acc
                };
      }
    } else {
      var match$1 = Belt_Array.getExn(inst, cur);
      var value = match$1[1];
      var newHistory = Belt_Array.concat(history, [cur]);
      switch (match$1[0]) {
        case "acc" :
            _history = newHistory;
            _acc = acc + value | 0;
            _cur = cur + 1 | 0;
            continue ;
        case "jmp" :
            _history = newHistory;
            _cur = cur + value | 0;
            continue ;
        case "nop" :
            _history = newHistory;
            _cur = cur + 1 | 0;
            continue ;
        default:
          continue ;
      }
    }
  };
}

function run(instructions) {
  var acc = interpret(instructions, 0, 0, []);
  if (acc.TAG) {
    return acc._0;
  } else {
    return -1;
  }
}

function patch(brokenInstructions) {
  var finder = function (instructions, start) {
    var _pos = start;
    while(true) {
      var pos = _pos;
      var match = Belt_Array.getExn(instructions, pos);
      var command = match[0];
      if (command === "nop" || command === "jmp") {
        return [
                command,
                match[1],
                pos
              ];
      }
      _pos = pos + 1 | 0;
      continue ;
    };
  };
  var _instructions = brokenInstructions;
  var _brokenPos = 0;
  while(true) {
    var brokenPos = _brokenPos;
    var instructions = _instructions;
    var ac = interpret(instructions, 0, 0, []);
    if (!ac.TAG) {
      return ac._0;
    }
    var match = finder(instructions, brokenPos);
    var newBrokenPos = match[2];
    var command = match[0];
    var newCommand;
    switch (command) {
      case "jmp" :
          newCommand = "nop";
          break;
      case "nop" :
          newCommand = "jmp";
          break;
      default:
        newCommand = command;
    }
    var newInstructions = brokenInstructions.slice(0);
    newInstructions[newBrokenPos] = [
      newCommand,
      match[1]
    ];
    _brokenPos = newBrokenPos + 1 | 0;
    _instructions = newInstructions;
    continue ;
  };
}

var Interpreter = {
  parse: parse,
  interpret: interpret,
  run: run,
  patch: patch
};

console.log(run(parse(input)));

console.log(patch(parse(input)));

exports.inputTest = inputTest;
exports.input = input;
exports.Interpreter = Interpreter;
/* inputTest Not a pure module */
