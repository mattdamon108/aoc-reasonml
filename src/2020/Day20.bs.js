// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Belt_Id = require("bs-platform/lib/js/belt_Id.js");
var Belt_Map = require("bs-platform/lib/js/belt_Map.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Belt_MapString = require("bs-platform/lib/js/belt_MapString.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");

var inputTest = Fs.readFileSync("input/2020/d20test", "utf8").trim().split("\n\n");

var input = Fs.readFileSync("input/2020/d20", "utf8").trim().split("\n\n");

var cmp = Caml_obj.caml_compare;

var CoordCmp = Belt_Id.MakeComparable({
      cmp: cmp
    });

function parse(image) {
  var lines = image.split("\n");
  var reTile = /\d+/;
  var result = reTile.exec(Belt_Array.getExn(lines, 0));
  var title = result !== null ? Belt_Option.getExn(Caml_option.nullable_to_opt(Belt_Array.getExn(result, 0))) : "";
  var pixels = Belt_Array.reduceWithIndex(Belt_Array.sliceToEnd(lines, 1), Belt_Map.make(CoordCmp), (function (acc, line, idxY) {
          return Belt_Array.reduceWithIndex(line.split(""), acc, (function (ac, $$char, idxX) {
                        return Belt_Map.set(ac, [
                                    idxX,
                                    idxY
                                  ], $$char);
                      }));
        }));
  return [
          title,
          pixels
        ];
}

var parsed = Belt_Array.map(Belt_Array.map(inputTest, parse), (function (tile) {
        var pixels = tile[1];
        var top = Belt_Map.reduce(pixels, [], (function (acc, k, v) {
                if (k[1] === 0) {
                  return Belt_Array.concat(acc, [v]);
                } else {
                  return acc;
                }
              }));
        var right = Belt_Map.reduce(pixels, [], (function (acc, k, v) {
                if (k[0] === 9) {
                  return Belt_Array.concat(acc, [v]);
                } else {
                  return acc;
                }
              }));
        var bottom = Belt_Map.reduce(pixels, [], (function (acc, k, v) {
                if (k[1] === 9) {
                  return Belt_Array.concat(acc, [v]);
                } else {
                  return acc;
                }
              }));
        var left = Belt_Map.reduce(pixels, [], (function (acc, k, v) {
                if (k[0] === 0) {
                  return Belt_Array.concat(acc, [v]);
                } else {
                  return acc;
                }
              }));
        return [
                tile[0],
                [
                  top,
                  Belt_Array.reverse(top),
                  right,
                  Belt_Array.reverse(right),
                  bottom,
                  Belt_Array.reverse(bottom),
                  left,
                  Belt_Array.reverse(left)
                ]
              ];
      }));

function findCorner(xs, ys) {
  return Belt_Array.reduce(xs, undefined, (function (acc, x) {
                return Belt_Array.reduce(ys, acc, (function (ac, y) {
                              var edgesY = y[1];
                              var titleY = y[0];
                              var titleX = x[0];
                              var matchedEdges = Belt_Array.reduce(Belt_Array.reduce(x[1], [], (function (xcc, ex) {
                                          return Belt_Array.reduce(edgesY, xcc, (function (ycc, ey) {
                                                        if (Caml_obj.caml_equal(ex, ey) && titleX !== titleY) {
                                                          return Belt_Array.concat(ycc, [
                                                                      ex,
                                                                      ey
                                                                    ]);
                                                        } else {
                                                          return ycc;
                                                        }
                                                      }));
                                        })), [], (function (acc, item) {
                                      if (Belt_Array.some(acc, (function (i) {
                                                return Caml_obj.caml_equal(i, item);
                                              }))) {
                                        return acc;
                                      } else {
                                        return Belt_Array.concat(acc, [item]);
                                      }
                                    }));
                              var prevMatches = Belt_MapString.get(ac, titleX);
                              if (prevMatches !== undefined) {
                                return Belt_MapString.set(ac, titleX, prevMatches + (matchedEdges.length >> 1) | 0);
                              } else {
                                return Belt_MapString.set(ac, titleX, (matchedEdges.length >> 1));
                              }
                            }));
              }));
}

function findSides(xs, ys) {
  return Belt_Array.reduce(xs, undefined, (function (acc, x) {
                return Belt_Array.reduce(ys, acc, (function (ac, y) {
                              var edgesY = y[1];
                              var titleY = y[0];
                              var titleX = x[0];
                              var matchedEdges = Belt_Array.reduce(Belt_Array.reduce(x[1], [], (function (xcc, ex) {
                                          return Belt_Array.reduce(edgesY, xcc, (function (ycc, ey) {
                                                        if (Caml_obj.caml_equal(ex, ey) && titleX !== titleY) {
                                                          return Belt_Array.concat(ycc, [
                                                                      ex,
                                                                      ey
                                                                    ]);
                                                        } else {
                                                          return ycc;
                                                        }
                                                      }));
                                        })), [], (function (acc, item) {
                                      if (Belt_Array.some(acc, (function (i) {
                                                return Caml_obj.caml_equal(i, item);
                                              }))) {
                                        return acc;
                                      } else {
                                        return Belt_Array.concat(acc, [item]);
                                      }
                                    }));
                              if (matchedEdges.length < 2) {
                                return ac;
                              }
                              var prevMatches = Belt_MapString.get(ac, titleX);
                              if (prevMatches !== undefined) {
                                return Belt_MapString.set(ac, titleX, Belt_Array.concat(prevMatches, [titleY]));
                              } else {
                                return Belt_MapString.set(ac, titleX, [titleY]);
                              }
                            }));
              }));
}

function generateCanvas(images, total) {
  var length = Math.sqrt(total) | 0;
  return Belt_Array.reduceWithIndex(Belt_Array.range(0, length - 1 | 0), Belt_Map.make(CoordCmp), (function (acc, i, idxY) {
                return Belt_Array.reduceWithIndex(Belt_Array.range(0, length - 1 | 0), acc, (function (ac, j, idxX) {
                              return Belt_Map.set(ac, [
                                          idxX,
                                          idxY
                                        ], "");
                            }));
              }));
}

console.log(Belt_MapString.valuesToArray(findSides(parsed, parsed)));

var UndefinedCoord = Caml_exceptions.create("Day20-FirstReason.UndefinedCoord");

var UndefinedTitle = Caml_exceptions.create("Day20-FirstReason.UndefinedTitle");

function arrangeImages(images) {
  findSides(images, images);
  var total = images.length;
  var lengthOfSide = Math.sqrt(total) | 0;
  var corners = Belt_MapString.keysToArray(Belt_MapString.keep(findCorner(images, images), (function (k, v) {
              return v <= 2;
            })));
  Belt_Map.set(Belt_Map.set(Belt_Map.set(Belt_Map.set(generateCanvas(images, total), [
                    0,
                    0
                  ], Belt_Array.getExn(corners, 0)), [
                0,
                lengthOfSide - 1 | 0
              ], Belt_Array.getExn(corners, 1)), [
            lengthOfSide - 1 | 0,
            0
          ], Belt_Array.getExn(corners, 2)), [
        lengthOfSide - 1 | 0,
        lengthOfSide - 1 | 0
      ], Belt_Array.getExn(corners, 3));
  
}

exports.inputTest = inputTest;
exports.input = input;
exports.CoordCmp = CoordCmp;
exports.parse = parse;
exports.parsed = parsed;
exports.findCorner = findCorner;
exports.findSides = findSides;
exports.generateCanvas = generateCanvas;
exports.UndefinedCoord = UndefinedCoord;
exports.UndefinedTitle = UndefinedTitle;
exports.arrangeImages = arrangeImages;
/* inputTest Not a pure module */
