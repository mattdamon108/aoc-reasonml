// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");

var inputTest = Fs.readFileSync("input/2020/d18test", "utf8").trim().split("\n");

var input = Fs.readFileSync("input/2020/d18", "utf8").trim().split("\n");

var UndefinedOperator = Caml_exceptions.create("Day18-FirstReason.UndefinedOperator");

function parse(line) {
  return Belt_Array.keep(Belt_Array.map(line.split(""), (function (c) {
                    switch (c) {
                      case " " :
                          return /* Space */4;
                      case "(" :
                          return /* ParenOpen */2;
                      case ")" :
                          return /* ParenClose */3;
                      case "*" :
                          return /* Multiply */1;
                      case "+" :
                          return /* Add */0;
                      default:
                        return /* Num */{
                                _0: Caml_format.caml_float_of_string(c)
                              };
                    }
                  })), (function (c) {
                return c !== /* Space */4;
              }));
}

function addParenForward(arr) {
  var a = Belt_Array.reverse(arr);
  var _paren = 0;
  var _idx = 0;
  while(true) {
    var idx = _idx;
    var paren = _paren;
    var length = a.length;
    if (idx === (length - 1 | 0)) {
      return Belt_Array.reverse(Belt_Array.concat(a, [/* ParenOpen */2]));
    }
    var $$char = Belt_Array.getExn(a, idx);
    var front = Belt_Array.slice(a, 0, idx);
    var back = Belt_Array.sliceToEnd(a, idx + 1 | 0);
    if (typeof $$char === "number") {
      switch ($$char) {
        case /* Multiply */1 :
            if (paren === 0) {
              return Belt_Array.reverse(Belt_Array.concatMany([
                              front,
                              [
                                /* ParenOpen */2,
                                /* Multiply */1
                              ],
                              back
                            ]));
            }
            _idx = idx + 1 | 0;
            continue ;
        case /* ParenOpen */2 :
            if (paren === 0) {
              return Belt_Array.reverse(Belt_Array.concatMany([
                              front,
                              [
                                /* ParenOpen */2,
                                /* ParenOpen */2
                              ],
                              back
                            ]));
            }
            _idx = idx + 1 | 0;
            _paren = paren - 1 | 0;
            continue ;
        case /* ParenClose */3 :
            _idx = idx + 1 | 0;
            _paren = paren + 1 | 0;
            continue ;
        case /* Add */0 :
        case /* Space */4 :
            break;
        
      }
    }
    _idx = idx + 1 | 0;
    continue ;
  };
}

function addParenBackward(arr) {
  var _paren = 0;
  var _idx = 0;
  while(true) {
    var idx = _idx;
    var paren = _paren;
    var length = arr.length;
    if (idx === (length - 1 | 0)) {
      return Belt_Array.concat(arr, [/* ParenClose */3]);
    }
    var $$char = Belt_Array.getExn(arr, idx);
    var front = Belt_Array.slice(arr, 0, idx);
    var back = Belt_Array.sliceToEnd(arr, idx + 1 | 0);
    if (typeof $$char === "number") {
      switch ($$char) {
        case /* Multiply */1 :
            if (paren === 0) {
              return Belt_Array.concatMany([
                          front,
                          [
                            /* ParenClose */3,
                            /* Multiply */1
                          ],
                          back
                        ]);
            }
            _idx = idx + 1 | 0;
            continue ;
        case /* ParenOpen */2 :
            _idx = idx + 1 | 0;
            _paren = paren + 1 | 0;
            continue ;
        case /* ParenClose */3 :
            if (paren === 0) {
              return Belt_Array.concatMany([
                          front,
                          [
                            /* ParenClose */3,
                            /* ParenClose */3
                          ],
                          back
                        ]);
            }
            _idx = idx + 1 | 0;
            _paren = paren - 1 | 0;
            continue ;
        case /* Add */0 :
        case /* Space */4 :
            break;
        
      }
    }
    _idx = idx + 1 | 0;
    continue ;
  };
}

function addParen(line) {
  var _l = line;
  var _idx = 0;
  while(true) {
    var idx = _idx;
    var l = _l;
    var length = l.length;
    if (idx === (length - 1 | 0)) {
      return l;
    }
    var $$char = Belt_Array.getExn(l, idx);
    if (typeof $$char === "number") {
      if ($$char !== 0) {
        _idx = idx + 1 | 0;
        continue ;
      }
      var front = Belt_Array.slice(l, 0, idx);
      var back = Belt_Array.sliceToEnd(l, idx);
      var newFront = addParenForward(front);
      var newBack = addParenBackward(back);
      _idx = idx + 2 | 0;
      _l = Belt_Array.concatMany([
            newFront,
            newBack
          ]);
      continue ;
    }
    _idx = idx + 1 | 0;
    continue ;
  };
}

function calculate(n, m, op) {
  if (typeof op === "number") {
    if (op === 1) {
      return n * m;
    }
    if (op !== 0) {
      throw {
            RE_EXN_ID: UndefinedOperator,
            Error: new Error()
          };
    }
    return n + m;
  }
  throw {
        RE_EXN_ID: UndefinedOperator,
        Error: new Error()
      };
}

function compute(line) {
  var _l = line;
  var _acc = 0.0;
  var _op = /* Add */0;
  while(true) {
    var op = _op;
    var acc = _acc;
    var l = _l;
    if (l.length === 0) {
      return [
              acc,
              []
            ];
    }
    var first = Belt_Array.getExn(l, 0);
    var rest = Belt_Array.sliceToEnd(l, 1);
    if (typeof first === "number") {
      switch (first) {
        case /* Add */0 :
            _op = /* Add */0;
            _l = rest;
            continue ;
        case /* Multiply */1 :
            _op = /* Multiply */1;
            _l = rest;
            continue ;
        case /* ParenOpen */2 :
            var match = compute(rest);
            _acc = calculate(acc, match[0], op);
            _l = match[1];
            continue ;
        case /* ParenClose */3 :
        case /* Space */4 :
            return [
                    acc,
                    rest
                  ];
        
      }
    } else {
      _acc = calculate(acc, first._0, op);
      _l = rest;
      continue ;
    }
  };
}

console.log(Belt_Array.reduce(Belt_Array.map(Belt_Array.map(input, parse), compute), 0.0, (function (acc, i) {
            return acc + i[0];
          })));

console.log(Belt_Array.reduce(Belt_Array.map(Belt_Array.map(Belt_Array.map(input, parse), addParen), compute), 0.0, (function (acc, i) {
            return acc + i[0];
          })));

exports.inputTest = inputTest;
exports.input = input;
exports.UndefinedOperator = UndefinedOperator;
exports.parse = parse;
exports.addParenForward = addParenForward;
exports.addParenBackward = addParenBackward;
exports.addParen = addParen;
exports.calculate = calculate;
exports.compute = compute;
/* inputTest Not a pure module */
