// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Int64 = require("bs-platform/lib/js/int64.js");
var Belt_Id = require("bs-platform/lib/js/belt_Id.js");
var Belt_Map = require("bs-platform/lib/js/belt_Map.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Caml_int64 = require("bs-platform/lib/js/caml_int64.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Opt$FirstReason = require("../util/Opt.bs.js");
var Caml_splice_call = require("bs-platform/lib/js/caml_splice_call.js");

var inputTest = Fs.readFileSync("input/2020/day14test", "utf8").trim().split("\n");

var inputTest2 = Fs.readFileSync("input/2020/day14test2", "utf8").trim().split("\n");

var input = Fs.readFileSync("input/2020/day14", "utf8").trim().split("\n");

function parseMem(mem) {
  var reMem = /^mem\[(\d+)\]\s=\s(\d+)$/g;
  return Opt$FirstReason.let_(Caml_option.null_to_opt(reMem.exec(mem)), (function (result) {
                return Opt$FirstReason.let_(Caml_option.nullable_to_opt(Belt_Array.getExn(result, 1)), (function (pos) {
                              return Opt$FirstReason.let_(Caml_option.nullable_to_opt(Belt_Array.getExn(result, 2)), (function (value) {
                                            return [
                                                    Caml_format.caml_float_of_string(pos),
                                                    Caml_format.caml_float_of_string(value)
                                                  ];
                                          }));
                            }));
              }));
}

function parseMask(mask, replacement) {
  var __x = Belt_Array.map(mask.split(""), (function (i) {
          if (i === "X") {
            return replacement;
          } else {
            return i;
          }
        }));
  return Caml_splice_call.spliceObjApply("", "concat", [Belt_Array.concat(["0b"], __x)]);
}

function parseMask2(mask) {
  return Belt_Array.keep(Belt_Array.mapWithIndex(Belt_Array.reverse(mask.split("")), (function (idx, m) {
                    return [
                            idx,
                            m
                          ];
                  })), (function (msk) {
                return msk[1] === "X";
              }));
}

function masking(value, mask) {
  var bitmaskAND = Caml_format.caml_int64_of_string(parseMask(mask, "1"));
  var bitmaskOR = Caml_format.caml_int64_of_string(parseMask(mask, "0"));
  return Caml_int64.to_float(Caml_int64.or_(Caml_int64.and_(Caml_int64.of_float(value), bitmaskAND), bitmaskOR));
}

function masking2(address, mask) {
  var bitmaskOR = Caml_format.caml_int64_of_string(parseMask(mask, "0"));
  var maskedOr = Caml_int64.or_(Caml_int64.of_float(address), bitmaskOR);
  return Belt_Array.reduce(parseMask2(mask), [maskedOr], (function (acc, m) {
                var offset = m[0];
                return Belt_Array.reduce(acc, [], (function (ac, i) {
                              var overwrittenZero = Caml_int64.and_(i, Int64.lognot(Caml_int64.lsl_(Caml_int64.one, offset)));
                              var overwrittenOne = Caml_int64.or_(i, Caml_int64.lsl_(Caml_int64.one, offset));
                              return Belt_Array.concat(ac, [
                                          overwrittenZero,
                                          overwrittenOne
                                        ]);
                            }));
              }));
}

var cmp = Caml_obj.caml_compare;

var FloatCmp = Belt_Id.MakeComparable({
      cmp: cmp
    });

var match = Belt_Array.reduce(input, [
      Belt_Map.make(FloatCmp),
      ""
    ], (function (acc, code) {
        var accMask = acc[1];
        var accMap = acc[0];
        var splitted = code.split(" = ");
        var command = Belt_Array.getExn(splitted, 0);
        if (command === "mask") {
          return [
                  accMap,
                  Belt_Array.getExn(splitted, 1)
                ];
        }
        var match = parseMem(code);
        if (match === undefined) {
          return acc;
        }
        var value = masking(match[1], accMask);
        return [
                Belt_Map.set(accMap, match[0], value),
                accMask
              ];
      }));

var map = match[0];

var match$1 = Belt_Array.reduce(input, [
      Belt_Map.make(FloatCmp),
      ""
    ], (function (acc, code) {
        var accMask = acc[1];
        var accMap = acc[0];
        var splitted = code.split(" = ");
        var command = Belt_Array.getExn(splitted, 0);
        if (command === "mask") {
          return [
                  accMap,
                  Belt_Array.getExn(splitted, 1)
                ];
        }
        var match = parseMem(code);
        if (match === undefined) {
          return acc;
        }
        var v = match[1];
        var addresses = masking2(match[0], accMask);
        var newMap = Belt_Array.reduce(addresses, accMap, (function (acc, adr) {
                return Belt_Map.set(acc, Caml_int64.to_float(adr), v);
              }));
        return [
                newMap,
                accMask
              ];
      }));

var map2 = match$1[0];

console.log(Belt_Map.reduce(map, 0.0, (function (acc, param, v) {
            return acc + v;
          })));

console.log(Belt_Map.reduce(map2, 0.0, (function (acc, param, v) {
            return acc + v;
          })));

var mask = match$1[1];

exports.inputTest = inputTest;
exports.inputTest2 = inputTest2;
exports.input = input;
exports.parseMem = parseMem;
exports.parseMask = parseMask;
exports.parseMask2 = parseMask2;
exports.masking = masking;
exports.masking2 = masking2;
exports.FloatCmp = FloatCmp;
exports.map = map;
exports.map2 = map2;
exports.mask = mask;
/* inputTest Not a pure module */
