// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Belt_MapString = require("bs-platform/lib/js/belt_MapString.js");
var Belt_SetString = require("bs-platform/lib/js/belt_SetString.js");
var Opt$FirstReason = require("../util/Opt.bs.js");

var inputTest = Fs.readFileSync("input/2020/day07test", "utf8").trim().split("\n");

var inputTest2 = Fs.readFileSync("input/2020/day07test2", "utf8").trim().split("\n");

var input = Fs.readFileSync("input/2020/day07", "utf8").trim().split("\n");

function parseBag(bag) {
  var regexChildrenBag = /^(\d)\s([A-z]+\s[A-z]+)\sbags?\.?/g;
  return Opt$FirstReason.let_(Caml_option.null_to_opt(regexChildrenBag.exec(bag)), (function (result) {
                return Opt$FirstReason.let_(Caml_option.nullable_to_opt(Belt_Array.getExn(result, 1)), (function (countStr) {
                              return Opt$FirstReason.let_(Caml_option.nullable_to_opt(Belt_Array.getExn(result, 2)), (function (bag) {
                                            var count = Caml_format.caml_int_of_string(countStr);
                                            return [
                                                    count,
                                                    bag
                                                  ];
                                          }));
                            }));
              }));
}

var mapOfBagReverse = Belt_Array.reduce(Belt_Array.map(input, (function (line) {
            var splitted = line.split(" contain ");
            var parentBag = Belt_Array.getExn(splitted, 0).replace(" bags", "").replace(" bag", "");
            var matched = Belt_Array.map(Belt_Array.getExn(splitted, 1).replace(".", "").split(", "), parseBag);
            return [
                    parentBag,
                    matched
                  ];
          })), undefined, (function (map, line) {
        var parentBag = line[0];
        return Belt_Array.reduce(line[1], map, (function (acc, bag) {
                      if (bag === undefined) {
                        return acc;
                      }
                      var b = bag[1];
                      var p = Belt_MapString.get(acc, b);
                      if (p !== undefined) {
                        return Belt_MapString.set(acc, b, Belt_Array.concat(p, [parentBag]));
                      } else {
                        return Belt_MapString.set(acc, b, [parentBag]);
                      }
                    }));
      }));

var mapOfBag = Belt_Array.reduce(Belt_Array.map(input, (function (line) {
            var splitted = line.split(" contain ");
            var parentBag = Belt_Array.getExn(splitted, 0).replace(" bags", "").replace(" bag", "");
            var matched = Belt_Array.map(Belt_Array.getExn(splitted, 1).replace(".", "").split(", "), parseBag);
            return [
                    parentBag,
                    matched
                  ];
          })), undefined, (function (map, line) {
        return Belt_MapString.set(map, line[0], line[1]);
      }));

function counter(map, _bag, _acc) {
  while(true) {
    var acc = _acc;
    var bag = _bag;
    var containers = Belt_Array.map(bag, (function (b) {
            return Belt_MapString.getWithDefault(map, b, []);
          }));
    var spread = Belt_Array.reduce(containers, [], Belt_Array.concat);
    if (spread.length === 0) {
      return acc;
    }
    _acc = Belt_Array.concat(acc, spread);
    _bag = spread;
    continue ;
  };
}

function counter2(map, _bag, _count) {
  while(true) {
    var count = _count;
    var bag = _bag;
    var children = Belt_Array.reduce(bag, [], (function (acc, b) {
            var ct = b[0];
            return Belt_Array.reduce(Belt_MapString.getWithDefault(map, b[1], []), acc, (function (ac, child) {
                          if (child !== undefined) {
                            return Belt_Array.concat(ac, [[
                                          Math.imul(ct, child[0]),
                                          child[1]
                                        ]]);
                          } else {
                            return acc;
                          }
                        }));
          }));
    var newCount = Belt_Array.reduce(children, count, (function (acc, bag) {
            return acc + bag[0] | 0;
          }));
    if (children.length === 0) {
      return newCount;
    }
    _count = newCount;
    _bag = children;
    continue ;
  };
}

console.log(Belt_SetString.size(Belt_Array.reduce(counter(mapOfBagReverse, ["shiny gold"], []), undefined, Belt_SetString.add)));

console.log(counter2(mapOfBag, [[
            1,
            "shiny gold"
          ]], 0));

exports.inputTest = inputTest;
exports.inputTest2 = inputTest2;
exports.input = input;
exports.parseBag = parseBag;
exports.mapOfBagReverse = mapOfBagReverse;
exports.mapOfBag = mapOfBag;
exports.counter = counter;
exports.counter2 = counter2;
/* inputTest Not a pure module */
