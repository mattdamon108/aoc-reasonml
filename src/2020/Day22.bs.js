// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Belt_Id = require("bs-platform/lib/js/belt_Id.js");
var Belt_Map = require("bs-platform/lib/js/belt_Map.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");

var inputTest = Fs.readFileSync("input/2020/d22test", "utf8").trim().split("\n\n");

var input = Fs.readFileSync("input/2020/d22", "utf8").trim().split("\n\n");

function parse(lines) {
  return Belt_Array.map(Belt_Array.sliceToEnd(lines.split("\n"), 1), Caml_format.caml_int_of_string);
}

function loadDeck(data) {
  var deckP1 = parse(Belt_Array.getExn(data, 0));
  var deckP2 = parse(Belt_Array.getExn(data, 1));
  return [
          deckP1,
          deckP2
        ];
}

function score(param) {
  if (param[2]) {
    return Belt_Array.reduceWithIndex(Belt_Array.reverse(param[1]), 0, (function (acc, card, idx) {
                  return acc + Math.imul(idx + 1 | 0, card) | 0;
                }));
  } else {
    return Belt_Array.reduceWithIndex(Belt_Array.reverse(param[0]), 0, (function (acc, card, idx) {
                  return acc + Math.imul(idx + 1 | 0, card) | 0;
                }));
  }
}

function play(param) {
  var _dp1 = param[0];
  var _dp2 = param[1];
  while(true) {
    var dp2 = _dp2;
    var dp1 = _dp1;
    var havingP1 = dp1.length;
    var havingP2 = dp2.length;
    if (havingP1 === 0 || havingP2 === 0) {
      return [
              dp1,
              dp2,
              havingP1 === 0 ? /* P2 */1 : /* P1 */0
            ];
    }
    var drawP1 = Belt_Array.getExn(dp1, 0);
    var deckP1AfterDraw = Belt_Array.sliceToEnd(dp1, 1);
    var drawP2 = Belt_Array.getExn(dp2, 0);
    var deckP2AfterDraw = Belt_Array.sliceToEnd(dp2, 1);
    if (Caml_obj.caml_greaterthan(drawP1, drawP2)) {
      var newDeckP1 = Belt_Array.concat(deckP1AfterDraw, [
            drawP1,
            drawP2
          ]);
      _dp2 = deckP2AfterDraw;
      _dp1 = newDeckP1;
      continue ;
    }
    var newDeckP2 = Belt_Array.concat(deckP2AfterDraw, [
          drawP2,
          drawP1
        ]);
    _dp2 = newDeckP2;
    _dp1 = deckP1AfterDraw;
    continue ;
  };
}

var cmp = Caml_obj.caml_compare;

var DeckCmp = Belt_Id.MakeComparable({
      cmp: cmp
    });

function playRecursive(param) {
  var topRoll = function (deckP1$prime, deckP2$prime) {
    var history1 = Belt_Map.make(DeckCmp);
    var history2 = Belt_Map.make(DeckCmp);
    var _dp1 = deckP1$prime;
    var _dp2 = deckP2$prime;
    var _h1 = history1;
    var _h2 = history2;
    while(true) {
      var h2 = _h2;
      var h1 = _h1;
      var dp2 = _dp2;
      var dp1 = _dp1;
      var havingP1 = dp1.length;
      var havingP2 = dp2.length;
      if (havingP1 === 0 || havingP2 === 0) {
        return [
                dp1,
                dp2,
                havingP1 === 0 ? /* P2 */1 : /* P1 */0
              ];
      }
      var match = Belt_Map.get(h1, dp1);
      var match$1 = Belt_Map.get(h2, dp2);
      if (match !== undefined && match$1 !== undefined) {
        return [
                dp1,
                dp2,
                /* P1 */0
              ];
      }
      var newH1 = Belt_Map.set(h1, dp1, 0);
      var newH2 = Belt_Map.set(h2, dp2, 0);
      var drawP1 = Belt_Array.getExn(dp1, 0);
      var deckP1AfterDraw = Belt_Array.sliceToEnd(dp1, 1);
      var drawP2 = Belt_Array.getExn(dp2, 0);
      var deckP2AfterDraw = Belt_Array.sliceToEnd(dp2, 1);
      if (deckP1AfterDraw.length >= drawP1 && deckP2AfterDraw.length >= drawP2) {
        var match$2 = topRoll(Belt_Array.slice(deckP1AfterDraw, 0, drawP1), Belt_Array.slice(deckP2AfterDraw, 0, drawP2));
        if (match$2[2]) {
          var newDeckP2 = Belt_Array.concat(deckP2AfterDraw, [
                drawP2,
                drawP1
              ]);
          _h2 = newH2;
          _h1 = newH1;
          _dp2 = newDeckP2;
          _dp1 = deckP1AfterDraw;
          continue ;
        }
        var newDeckP1 = Belt_Array.concat(deckP1AfterDraw, [
              drawP1,
              drawP2
            ]);
        _h2 = newH2;
        _h1 = newH1;
        _dp2 = deckP2AfterDraw;
        _dp1 = newDeckP1;
        continue ;
      }
      if (drawP1 > drawP2) {
        var newDeckP1$1 = Belt_Array.concat(deckP1AfterDraw, [
              drawP1,
              drawP2
            ]);
        _h2 = newH2;
        _h1 = newH1;
        _dp2 = deckP2AfterDraw;
        _dp1 = newDeckP1$1;
        continue ;
      }
      var newDeckP2$1 = Belt_Array.concat(deckP2AfterDraw, [
            drawP2,
            drawP1
          ]);
      _h2 = newH2;
      _h1 = newH1;
      _dp2 = newDeckP2$1;
      _dp1 = deckP1AfterDraw;
      continue ;
    };
  };
  return topRoll(param[0], param[1]);
}

var CrabCombat = {
  loadDeck: loadDeck,
  score: score,
  play: play,
  playRecursive: playRecursive
};

function part1(data) {
  console.log(score(play(loadDeck(data))));
  
}

function part2(data) {
  console.log(score(playRecursive(loadDeck(data))));
  
}

var Solve = {
  part1: part1,
  part2: part2
};

part1(input);

part2(input);

exports.inputTest = inputTest;
exports.input = input;
exports.parse = parse;
exports.CrabCombat = CrabCombat;
exports.Solve = Solve;
/* inputTest Not a pure module */
